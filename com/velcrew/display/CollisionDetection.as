/* AS3	Copyright 2009 __Velcrew__.*/package com.velcrew.display{		import flash.display.*;	import flash.geom.*;	import flash.geom.Matrix;	import flash.geom.Rectangle;		 /**	 *		 * transport to AS3 from	 * class com.gskinner.sprites.CollisionDetection	 * GTween by Grant Skinner. Aug 1, 2005	 * Visit www.gskinner.com/blog for documentation, updates and more free code.	 *	 *	 * Copyright (c) 2005 Grant Skinner	 *	 *	@langversion ActionScript 3.0	 *	@playerversion Flash 9.0	 *	 *	@author Luis Teixeira	 *	@since  26.06.2009	 */	public class CollisionDetection 	{				public static function checkForCollision(stage:*,mc:MovieClip,target:MovieClip,targetTolerance:Number = 255) : Rectangle//: Boolean 		{						var _mc 			 : MovieClip;			var _target 		 : MovieClip;			var _targetTolerance : Number;			var _mcBounds 		 : Object;			var _targetBounds    : Object;						_mc 				= mc;			_target 			= target;			_targetTolerance	= targetTolerance;						_mcBounds = _mc.getBounds(stage);			_targetBounds = _target.getBounds(stage);						//trace(_mcBounds.x)								if (((_mcBounds.width+_mcBounds.x < _targetBounds.x) || (_targetBounds.width+_targetBounds.x < _mcBounds.x)) || ((_mcBounds.height+_mcBounds.y < _targetBounds.y) || (_targetBounds.height+_targetBounds.y < _mcBounds.y)) ) 			{				//return false;				return null;			}				// determine test area boundaries:			var bounds:Object = {};			bounds.xMin = Math.max(_mcBounds.x,_targetBounds.x);			bounds.xMax = Math.min(_mcBounds.width+_mcBounds.x,_targetBounds.width+_targetBounds.x);			bounds.yMin = Math.max(_mcBounds.y,_targetBounds.y);			bounds.yMax = Math.min(_mcBounds.height+_mcBounds.y,_targetBounds.height+_targetBounds.y);						// set up the image to use:			var img:BitmapData = new BitmapData(bounds.xMax-bounds.xMin,bounds.yMax-bounds.yMin,false);			// draw in the first image:			var mat:Matrix = _mc.transform.concatenatedMatrix;			mat.tx -= bounds.xMin;			mat.ty -= bounds.yMin;			img.draw(_mc,mat, new ColorTransform(1,1,1,1,255,-255,-255,_targetTolerance));			// overlay the second image:			mat = _target.transform.concatenatedMatrix;			mat.tx -= bounds.xMin;			mat.ty -= bounds.yMin;			img.draw(_target,mat, new ColorTransform(1,1,1,1,255,255,255,_targetTolerance),"difference");			// find the intersection:			var intersection:Rectangle = img.getColorBoundsRect(0xFFFFFFFF,0xFF00FFFF);			// if there is no intersection, return null:			if (intersection.width == 0) { return null;/*return false;*/ }			// adjust the intersection to account for the bounds:			intersection.x += bounds.xMin;			intersection.y += bounds.yMin;			//return true;						return intersection;								}	}	}